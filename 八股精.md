##### interface 和 type

interface 支持声明合并，不能定义联合类型，可以定义交叉类型(通过 extends 合并对象)
type 不支持声明合并，能定义基本类型别名、联合类型、交叉类型、元祖
interface 主要用于定义对象类型，以 interface 关键字开头，后接类型名称和类型定义

###### any,unknown,never 的区别

any 可以偷懒，暂时绕过类型检查
unknown 类型同样表示任意类型，但 unknown 是安全的，可以先将它声明为 unknown 类型，使用该变量前，必须先进行类型检查
never 类型表示永远不会出现的值，常用于表示不会返回的函数的返回值的类型

不能在 if、循环或嵌套函数中调用 hooks，原因是 react 依赖于固定不变的调用顺序来关联 hook 和其内部状态
解决方案是始终在组件顶层调用所有 hooks

##### useEffect

第二个参数，通常被称为依赖数组，作用是告诉 react 在什么时机重新执行 useEffect 内部的副作用函数

1. 第二个参数未提供时：
   **每次渲染都执行**，相当于类组件的 componentDidMount+componentDidUpdate
   容易造成死循环

2. 第二个参数是空数组[]:
   **仅在初始渲染后执行一次**，相当于类组件的 componentDidMount+componentWillUnmount
   ，获取初始数据、**设置事件监听、订阅**
3. 依赖数组[a,b]
   初始渲染后执行，且当 a 或 b 变化后再次执行，相当于 componentDidMount+componentDidUpdate(带条件的判断)

##### 如何去实现 react 中生命周期类似的效果

###### constructor-用 useState 初始化状态，函数直接定义即可

```js
function Component(props) {
  const [count, setCount] = useState(0);
}
```

###### componentDidMount

目的：组件挂载到 DOM 后立即执行，通常用于 API 请求、设置订阅，只执行一次,表示的意思是"挂载完成"

```js
import {useEffect,setData}=useState(null)
function Example(){
    const [data,setData]=useState(null)
    useEffect(()=>{
        console.log('has mounted')
    },[])
}
```

###### componentDidUpdate

目的：组件更新后立即执行，可以访问更新前的 props 和 state
Hooks 实现：使用 useEffect 并传入包含依赖项的数组[prop,state]

###### componentWillUnmount

目的:在组件卸载和销毁前立即执行，用于执行任何必要的清理工作，清除订阅、计时器
Hooks 实现:在 useEffect 的回调函数中**返回一个清理函数**

```js
function Example() {
  useEffect(() => {
    return () => {
      window.removeEventListener();
    };
  });
}
```
