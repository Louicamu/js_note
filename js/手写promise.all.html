<script>
function promiseAll(promises){
    return new Promise(function(resolve,reject){
        if(!Array.isArray(promises)){
            throw new TypeError('argument must not be an array')
        }
        var resolvedCounter=0
        var promiseNum=promises.length
        var resolvedResult=[]
        for(let i=0;i<promiseNum;i++){
            Promise.resolve(promises[i]).then(value=>{
                resolvedCounter++/*不管promise数组中的第i个元素是什么类型，都把它转换成一个标准的promise。然后为这个promise注册一个成功回调函数
                    以便当它完成时，我们可以拿到它的解析值value，并执行后续的逻辑
                */
                resolvedResult[i]=value
                if(resolvedCounter==promiseNum){
                    return resolve(resolvedResult)
                }
            },error=>{
                return reject(error)
            })
        }
    })
}
let p1=new Promise(function(resolve,reject){
    setTimeout(function(){
        resolve(1)
    },1000)
})
let p2=new Promise(function (resolve,reject){
    setTimeout(function(){
        resolve(2)
    },2000)
})
let p3=new Promise(function (resolve,reject){
    setTimeout(function(){
        resolve(3)
    },3000)
})
promiseAll([p3,p1,p2]).then(res=>{
    console.log(res)
})

//将多个promise实例包装成一个新的promise实例，这个新的promise用于处理并发操作
//它会等待所有任务都成功完成后，才宣告整个团队任务成功
//如果任何一个失败了整个团队任务立刻宣告失败
</script>

