### 安恒信息一面

1. 对于第三方的库，有没有了解一些原生的 api，怎么确定 api 是否满足当前浏览器的一个运行环境.有些 api 会在浏览器里面报错，有没有什么方法让它不报错
2. css 中的行内元素和块级元素，Tailwind CSS 中的事件是如何实现的
3. js 事件和事件的传递是怎么样的
4. useEffect 第二个参数的作用
5. 怎么去实现 react 中的类组件生命周期类似的效果

### 美团一面

1. css:三行三列的九宫格布局弹性盒子
   相对定位和绝对定位
```css
.grid-container{
  display: grid;
grid-template-columns:repeat(3,1fr);
grid-template-rows:repeat(3,1fr);
}
```



2. js:let const var
###### 作用域
var声明的变量具有**函数作用域和全局作用域**，这意味着变量在函数内部都是可访问的
```js
function exampleVar(){
  if(true){
    var x=10
  }
  console.log(x)//输出10，因为x的作用域是整个函数
}
```
let和const:都是在es6中引入的，他们具有**块级作用域**，只在块内可用，使得代码具有可预测性和可维护性
```js
  function exampleLet(){
    if(true){
      let y=20
    }
    console.log(y)//抛出referenceError:y is not defined因为y只在if块内可用
  }
```
###### 变量提升
：是javascript将声明移动到作用域顶部的行为
**var**:var声明的变量会被提升到作用域的顶部，并被初始化为undefined，在声明变量之前打印它，会得到undefined
```js
console.log(a)
var a=5;
```
**let和const**：他们声明的变量也会被提升，但他们不会被初始化，在声明之前打印他们，会进入一个暂时性死区,从而导致referenceError
```js
console.log(b)
let b=10
```
###### const声明的变量的值可以修改吗
对于基本数据类型：值不可以修改
对于对象数据类型(Object,Array)：值可以修改，可以修改对象或数组内部的属性或元素，不能将该变量重新赋值给一个新的对象或数组
```js
const person={
  name:'1',
  age:30
}
person.name="李四",
person.age=31,
person.city="北京"//甚至可以添加新属性
```
###### 重新赋值用let，const不可以重新赋值


###### setInterval()
每三秒展示当前的时间的定时器，适合用的 API 是 setInterval() 以固定间隔重复执行,setTimeout 是在指定延迟后执行一次

```js
function display() {
  const now = new Date();
  const formattedTime = now.toLocaleTimeString();
}
const timerId = setInterval(display, 3000);
```

我现在有一串数字，比如 123456789，我想每三位给这个数字加一个逗号， 比如 123,456,789 该如何实现呢
使用内置的 toLocaleString()

```js
const number = 123456789;
const formattedString1 = number.toLocaleString();
const formattedString2 = number.toLocaleString;
```

###### Promise 用来解决什么问题
用来解决js中异步操作的**回调地狱**问题
回调地狱：代码层层嵌套，可读性差，难维护
```js
function ajaxPromise(url){
  return new Promise((resolve,reject)=>{
    setTimeout(()=>{
      console.log(`正在请求：${url}`);
      const data={userId:1,orders[101,102]}
      resolve(data)
    },1000)
  })
}
ajaxPromise('/api/user)
.then(user=>{
  return ajaxPromise(`/api/orders?userId=${user.userId}`)
})
.then(orders=>{
  return ajaxPromise(`/api/render?orders=${orders}`)
})
.then(result=>{
  console.log(`页面渲染完成`)
})
.catch(error=>{
  console.error('链条发生了错误:',error)
})
```


### 安克一面
##### react组件通信
###### 父组件向子组件通信
父组件向child component传递一个名为message的prop
子组件通过prop.message访问该数据
###### 子组件向父组件通信
父组件 定义一个handleChildClick方法，并将其作为onClick prop传递给子组件
子组件在内部的按钮被点击时，调用this.props.onClick(),从而执行handleChildClick方法
###### 状态管理库
1. 工作原理：Redux将整个应用的state存储在一个称为store的地方，任何组件都可以从store中读取状态，通过分发action来更新状态，状态改变时，所有订阅了该状态的组件都会自动重新渲染

##### git遇到冲突怎么办


##### 什么时候用useMemo,useCallback
###### useMemo，缓存一个值
它的依赖项扮演了开关的角色，决定了useMemo是否需要重新执行计算
**如果依赖项没有变化**：useMemo会跳过计算，直接返回之前缓存的值
**如果依赖项发生变化**：useMemo会重新执行计算函数，
1. 进行昂贵的计算时
```js
const visibleTodos=useMemo(()=>{
  return filterTodos(todos,tab)
},[todos,tab])
```
2. 避免子组件不必要的重新渲染

###### useCallback 缓存一个函数本身（函数引用
1. 避免因函数引用变化导致子组件不必要的重新渲染
```js
const fetchData=useCallback(async()=>{
  const response=await fetch(url)
  const result=await response.json()
  setData(result)
},[url])
useEffect(()=>{
  fetchData()
},[fetchData])

```

### 美团二面
#### 设计模式
以google drive项目为例
##### 组合模式：将对象组合成“部分-整体”的结构
需要对单个文件和一个文件夹执行统一的操作，比如移动、删除、重命名或计算总大小
##### 观察者模式
文档对象时被观察者，用户的UI视图是观察者，文档内容改变时，会调用notifyObservers()方法，所有注册的视图都会收到通知并刷新自己的显示

#### useEffect和useLayoutEffect的区别
useEffect用在渲染和DOM更新后，异步执行，这意味着它不会阻塞浏览器的绘制过程。
优先使用useEffect，可以满足**数据获取、设置订阅**大部分副作用场景
useEffect用来替代componentDidMount和componentDidUpdate
useLayoutEffect用在**DOM更新后，浏览器绘制之前**，同步执行，会阻塞浏览器的绘制过程

#### useContext
##### 属性钻探(Prop Drilling)
例子：有一个顶层组件，它持有一些所有子组件都需要的数据，例如当前登录的用户名或网站的主题(白天、黑夜模式)
在没有useContext的情况下，需要将这些数据作为props一层一层地传递下去，即使中间的很多组件根本用不到这些数据

1. 创建Context
```js
import {createContext} from 'react'
export const ThemeContext=createContext('light')
```
2. 提供Context
```js
import React,{useState} from 'react'
import {ThemeContext} from 
function App(){
  const [theme,setTheme]=useState('dark')
  const ToggleTheme=()=>{
    setTheme(prevTheme=>(prevTheme=='light'?'dark':'light'))
  }
  return (
    <ThemeContext.Provider value={{theme,toggleTheme}} >
      <Toolbar>
    </ThemeContext.Provider>
  )
}
export default App;
```
##### 什么时候使用
**UI主题管理**：白天、黑夜切换
**用户认证信息**:在应用的任何地方获取当前登录用户的信息